---
description: deriving the points of rounded rectangle starting from the points that define a circle
published_date: 2025-02-14
title: how to derive a rounded rectangle shape
---

import CircleApp from "./circle_app.svelte";
import RoundedRectangleApp from "./rounded_rectangle_app.svelte";
import TerminologyApp from "./terminology_app.svelte";
import get_circular_points from "./get_circular_points?raw";
import get_rounded_rectangle_points from "./get_rounded_rectangle_points?raw";
import tcg_cards from "./tcg-cards.png";
import { Code } from "astro-expressive-code/components";
import { Picture } from "astro:assets";

export const corner_radius = 30;
export const corner_radius_max = 100;
export const corner_radius_min = 0;
export const corner_radius_step = 1;
export const inner_height = 90;
export const inner_height_max = 100;
export const inner_height_min = 0;
export const inner_height_step = 1;
export const inner_width = 70;
export const inner_width_max = 100;
export const inner_width_min = 0;
export const inner_width_step = 1;
export const point_count = 25;
export const point_count_max = 50;
export const point_count_min = 3;
export const point_count_step = 1;
export const point_radius = 1;
export const stroke_dash = 5;
export const text_offset_multiplier = 10;

<Picture
	alt="pokemon cards"
	formats={["avif", "webp"]}
	src={tcg_cards}
/>

Trading Card Game (TCG) cards tend to have a "rounded rectangle" shape to them. Pokemon cards, Yu-Gi-Oh cards, even Magic: the Gathering cards all have rounded edges. I had a need for such a shape in [three.js](https://threejs.org) but came to find that three.js didn't have an out-of-the-box solution.

<aside>
	Creating custom 2D geometries in three.js is actually pretty simple using the
	[Shape](https://threejs.org/docs/index.html#api/en/extras/core/Shape) and
	[ShapeGeometry](https://threejs.org/docs/index.html#api/en/geometries/ShapeGeometry)
	classes but these are designed to be very generic and to work with any shape
	path. For that reason, shapes generated by the `Shape` class may not be the
	most optimal.
</aside>

I wanted to see if I could create a rounded rectangle shape the same way that other geometries such as [CircleGeometry](https://github.com/mrdoob/three.js/blob/master/src/geometries/CircleGeometry.js) are created.

## Terminology

It's always a good idea to define some things before tackling the problem. Here's some things I'll refer to and a picture to go along with it.

- `corner radius` :: the radius of the circle that defines a corner of the rounded rectangle
- `outer width` :: the total width of the rectangle including the `corner radius` at each end
- `inner width` :: `outer width` minus the `corner radius` at each end
- `outer height` :: the total height of the rectangle including the `corner radius` at each end
- `inner height` :: `outer height` minus the `corner radius` at each end

<TerminologyApp
	client:visible
	corner_radius={corner_radius}
	inner_width={inner_width}
	inner_height={inner_height}
	line_stroke_dash={stroke_dash}
/>

## Planning

Most problems are solved by breaking the problem up into smaller pieces. I imagined what would a rounded rectangle look like if it had 0 inner width and 0 inner height. In that case all you'd be left with is the corner radius contributing to the total width and total height, in other words, you'd be left with a circle.

### Getting Points Around a Circle

<CircleApp
	client:visible
	point_count={point_count}
	point_count_max={point_count_max}
	point_count_min={point_count_min}
	point_count_step={point_count_step}
	radius={corner_radius}
	radius_max={corner_radius_max}
	radius_min={corner_radius_min}
	radius_step={corner_radius_step}
/>

There's a very simple formula for getting the points around a circle.

<Code
	code={get_circular_points}
	lang="ts"
	mark={{ range: "14-15" }}
/>

The code above highlights where the point's x and y can be adjusted.

## Applying an Offset

Pushing the points is applied as an offset to the x and y. There's two components to the offset.

1. Magnitude :: the "distance" to push
2. Direction :: should the push be positive or negative?

Looking at it this way you can see that the push is really a vector offset but that's a topic for another day. With this in mind, code that pushes the points by some amount in some direction would look like the following

```typescript showLineNumbers=false
const x = directionX * offsetX + radius * Math.cos(a));
const y = directionY * offsetY + radius * Math.cos(a));
```

So the question now becomes: "what should the offset and direction be such that the end result gives the rounded rectangle?

## Determining the Offset and the Direction

So we essentially need to figure out two pieces of information.

1. how much should the point be offset by
2. which direction should the point be pushed?

Both these apply separately to the x-axis and y-axis.

### Offset

To determine how much to push the point, all we need to do is think about a rounded rectangle that hasn't had its points pushed out at all. In this case, we'd end up with a circle of radius `corner radius`. We know the `outer width` of the rectangle is equal to `inner width + 2 * corner radius`. The circle will contribute `2 * corner radius` to this width leaving `inner_width`. The remaning width needs to be split between each side of the rectangle. This means that the distance to push out the quarter of the circle in the x-direction is half the `inner_width`.

The same argument applies when determining how far to push the point in the y-direction substituting `width` for `height`.

### Direction

The direction is determined by thinking about what quadrant a point lies in.

If the point lies in quadrant 1, the point needs to be pushed in the positive-x direction and in the postive-y direction. Here's a table showing which direction and sign correspond to each quadrant.

| quadrant | x-direction | y-direction | sign(point.x) | sign(point.y) |
| -------- | ----------- | ----------- | ------------- | ------------- |
| 1        | 1           | 1           | +             | +             |
| 2        | -1          | 1           | -             | +             |
| 3        | -1          | -1          | -             | -             |
| 4        | 1           | -1          | +             | -             |

The multiplier or direction to push the point is equal to the sign of its component in that axis. This gives us a really easy way to calculate the direction to push the point

```typescript showLineNumbers=false
const directionX = Math.sign(point.x);
const directionY = Math.sign(point.y);
```

## The Code

Now that we know the distance to push and the direction, all we need to do is bring it into our equation from before.

<Code
	code={get_rounded_rectangle_points}
	mark={{ range: "19-20, 22-23" }}
	lang="ts"
/>

<RoundedRectangleApp
	client:visible
	corner_radius={corner_radius}
	corner_radius_max={corner_radius_max}
	corner_radius_min={corner_radius_min}
	corner_radius_step={corner_radius_step}
	inner_height={inner_height}
	inner_height_max={inner_height_max}
	inner_height_min={inner_height_min}
	inner_height_step={inner_height_step}
	inner_width={inner_width}
	inner_width_max={inner_width_max}
	inner_width_min={inner_width_min}
	inner_width_step={inner_width_step}
	point_count={point_count}
	point_count_max={point_count_max}
	point_count_min={point_count_min}
/>
